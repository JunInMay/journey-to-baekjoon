# 로고
"""
로고는 주로 교육용에 쓰이는 프로그래밍 언어이다.
로고의 가장 큰 특징은 거북이 로봇인데, 사용자는 이 거북이 로봇을 움직이는 명령을 입력해 화면에 도형을 그릴 수 있다.

거북이는 위치와 각도로 표현할 수 있다.
거북이는 입에 연필을 물고 있는데, 연필을 내리면 움직일 때 화면에 선을 그리고, 올리면 선을 그리지 않고 그냥 지나가기만 한다.

제일 처음에 거북이는 (0,0)에 있고, 거북이가 보고 있는 방향은 y축이 증가하는 방향이다. 또한 연필은 내리고 있다.

사용자는 다음과 같은 다섯가지 명령으로 거북이를 조정할 수 있다.

FD x: 거북이를 x만큼 앞으로 전진
LT a: 거북이를 반시계 방향으로 a도 만큼 회전
RT a: 거북이를 시계 방향으로 a도 만큼 회전
PU: 연필을 올린다
PD: 연필을 내린다.
축에 평행한 직사각형 N개가 주어졌을 때, 이 직사각형을 그리는데 필요한 PU 명령의 최솟값을 구하는 프로그램을 작성하시오.

거북이는 같은 선을 여러 번 그릴 수 있지만, 문제에 주어진 직사각형 N개를 제외한 어떤 것도 그릴 수 없다.
거북이의 크기는 아주 작아서 좌표 평면의 한 점이라고 생각하면 된다. 직사각형의 변은 축에 평행하다.
"""
"""
유니온 파인드(Union-Find)가 뭔지 몰라서 bfs로만 풀었다..?
문제 의도가 분리집합이면 왜 이렇게 풀렸을까
일단 유니온 파인드, 분리집합에 대해 공부해봐야겠다.
"""
"""
[혹시모를 미래를 위해서 풀이 남기기]
-500~500까지가 좌표 범위니까 이차원 배열 1001 * 1001을 준비
사각형을 그리면 그 격자들을 지나치게 됨 예를 들어 2 2 4 4가 입력되면 사각형의 왼쪽 선분은 2,2~ 2,4 까지 격자를 2개 지나치게 됨(2,3, 2,4로 2개)
이렇게 사각형을 마치 그래프처럼 나타낼 수 있음
그래프를 만들 때 주의할 점은 문제에선 여러 개의 사각형을 주고 있으므로 사각형마다 선분이 겹칠 수가 있음
따라서 여기서는 set를 써서 중복되는 선분을 제거함 -> if, in을 통해서 제거할 수도 있음
연필을 내린 상태에서 시작해서 사각형을 모두 그릴 때 까지 연필을 올릴 최소 횟수를 구하는 것이 문제임
연필을 올리는 경우는 임의의 사각형이 포함하고있는 임의의 선분의 임의의 점에서 시작해서 그 점에서 이어진 모든 선분을 탐색했을 때 연필을 올려야 최적의 해가 나옴
즉 그래프의 연결 요소를 구하면 됨
그런데 시작점은 0, 0이므로 만약 0, 0에 연결된 사각형 선분이 있다면 그 연결요소는 세면(count) 안됨

그러나 풀고나니 유니온 파인드로 푸는 문제라고 함
"""
import sys
from collections import deque


def bfs(start):
    y, x = start
    queue = deque([(y, x)])
    visited[y][x] = True
    res = 1
    # 시작점이 0, 0이면 해당 그래프를 연결요소로 쳐주지 않는다. 왜냐하면 0, 0에서 연필을 내린채로 시작하기 때문이다.
    if y == x and y == 500:
        res = 0

    while queue:
        y, x = queue.popleft()
        # 그래프에 있는 임의의 점이 0, 0이면 해당 그래프를 연결요소로 쳐주지 않는다. 왜냐하면 0, 0에서 연필을 내린채로 시작하기 때문이다.
        if y == x and y == 500:
            res = 0
        for cand in graph[y][x]:
            nY, nX = cand

            if not visited[nY][nX]:
                visited[nY][nX] = True
                queue.append((nY, nX))

    return res


graph = [[set() for _ in range(1001)] for _ in range(1001)]
visited = [[False for _ in range(1001)] for _ in range(1001)]
for _ in range(int(sys.stdin.readline().rstrip())):
    # -500~500까지 입력이 들어올텐데 인덱스는 0~1000까지이므로 이를 맞추기 위해서 500을 더해줌 0, 0 = 500, 500이 됨
    x1, y1, x2, y2 = map(lambda x : x+500, map(int, sys.stdin.readline().rstrip().split()))
    # 상하(위아래 변) 그래프 만들기
    for i in range(x1, x2):
        graph[y1][i].add((y1, i+1))
        graph[y1][i+1].add((y1, i))
        graph[y2][i].add((y2, i+1))
        graph[y2][i+1].add((y2, i))
    # 좌우(왼쪽 오른쪽 변) 그래프 만들기
    for i in range(y1, y2):
        graph[i][x1].add((i+1, x1))
        graph[i+1][x1].add((i, x1))
        graph[i][x2].add((i+1, x2))
        graph[i+1][x2].add((i, x2))

count = 0
# 시작점 탐색하기 : 해당 점을 방문하지 않아어야 하고, 사각형을 구성하는 한 점이어야 함
for i in range(1001):
    for j in range(1001):
        if not visited[i][j] and len(graph[i][j]):
            count += bfs((i, j))

print(count)



